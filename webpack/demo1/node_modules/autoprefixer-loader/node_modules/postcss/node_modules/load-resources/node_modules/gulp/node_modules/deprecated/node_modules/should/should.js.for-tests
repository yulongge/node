!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Should=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
 * Should
 * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

var should = require('./should');

should
  .use(require('./ext/assert'))
  .use(require('./ext/chain'))
  .use(require('./ext/bool'))
  .use(require('./ext/number'))
  .use(require('./ext/eql'))
  .use(require('./ext/type'))
  .use(require('./ext/string'))
  .use(require('./ext/property'))
  .use(require('./ext/error'))
  .use(require('./ext/match'))
  .use(require('./ext/browser/jquery'))
  .use(require('./ext/deprecated'));

 module.exports = should;
},{"./ext/assert":3,"./ext/bool":4,"./ext/browser/jquery":5,"./ext/chain":6,"./ext/deprecated":7,"./ext/eql":8,"./ext/error":9,"./ext/match":10,"./ext/number":11,"./ext/property":12,"./ext/string":13,"./ext/type":14,"./should":15}],2:[function(require,module,exports){
/*!
 * Should
 * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

// Taken from node's assert module, because it sucks
// and exposes next to nothing useful.
var util = require('./util');

module.exports = _deepEqual;

var pSlice = Array.prototype.slice;

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}


function objEquiv (a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (util.isArguments(a)) {
    if (!util.isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try{
    var ka = Object.keys(a),
      kb = Object.keys(b),
      key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

},{"./util":16}],3:[function(require,module,exports){
/*!
 * Should
 * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

var util = require('../util')
  , assert = require('assert')
  , AssertionError = assert.AssertionError;

module.exports = function(should) {
  var i = should.format;

  /**
   * Expose assert to should
   *
   * This allows you to do things like below
   * without require()ing the assert module.
   *
   *    should.equal(foo.bar, undefined);
   *
   */
  util.merge(should, assert);


  /**
   * Assert _obj_ exists, with optional message.
   *
   * @param {*} obj
   * @param {String} [msg]
   * @api public
   */
  should.exist = should.exists = function(obj, msg) {
    if(null == obj) {
      throw new AssertionError({
        message: msg || ('expected ' + i(obj) + ' to exist'), stackStartFunction: should.exist
      });
    }
  };

  /**
   * Asserts _obj_ does not exist, with optional message.
   *
   * @param {*} obj
   * @param {String} [msg]
   * @api public
   */

  should.not = {};
  should.not.exist = should.not.exists = function(obj, msg) {
    if(null != obj) {
      throw new AssertionError({
        message: msg || ('expected ' + i(obj) + ' to not exist'), stackStartFunction: should.not.exist
      });
    }
  };
};
},{"../util":16,"assert":17}],4:[function(require,module,exports){
/*!
 * Should
 * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

module.exports = function(should, Assertion) {
  Assertion.add('true', function() {
    this.is.exactly(true)
  }, true);

  Assertion.add('false', function() {
    this.is.exactly(false)
  }, true);

  Assertion.add('ok', function() {
    this.params = { operator: 'to be truthy' };

    this.assert(this.obj);
  }, true);
};
},{}],5:[function(require,module,exports){
/*!
 * Should
 * Copyright(c) 2010-2014 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/*!
 * Portions copyright (c) 2010, 2011, 2012 Wojciech Zawistowski, Travis Jeffery
 * From the jasmine-jquery project under the MIT License.
 */

var util = require('../../util');

module.exports = function(should, Assertion) {
  var i = should.format;
  var $ = this.jQuery || this.$;

  /* Otherwise, node's util.inspect loops hangs */
  if (typeof HTMLElement !== "undefined" && HTMLElement && !HTMLElement.prototype.inspect) {
    HTMLElement.prototype.inspect = function () {
      return this.outerHTML;
    };
  }

  if (typeof jQuery !== "undefined" && jQuery && !jQuery.prototype.inspect) {
    jQuery.fn.inspect = function () {
      var elementList = this.toArray().map(function (e) {
        return util.inspect(e);
      }).join(", ");
      if (this.selector) {
        return "SELECTOR(" + this.selector + ") matching " + this.length + " elements" + (elementList.length ? ": " + elementList : "");
      } else {
        return elementList;
      }
    };
  }

  function jQueryAttributeTestHelper(method, singular, plural, nameOrHash, value) {
    var keys = util.isObject(nameOrHash) ? Object.keys(nameOrHash) : [nameOrHash];
    var allRelevantAttributes = keys.reduce(function (memo, key) {
      var value = $(this.obj)[method](key);
      if (typeof value !== 'undefined') {
        memo[key] = value;
      }
      return memo;
    }.bind(this), {});

    if (arguments.length === 4 && util.isObject(nameOrHash)) {
      this.params = { operator: 'to have ' + plural + ' ' + i(nameOrHash) };
      allRelevantAttributes.should.have.properties(nameOrHash);
    } else if (arguments.length === 4) {
      this.params = { operator: 'to have ' + singular + ' ' + i(nameOrHash) };
      allRelevantAttributes.should.have.property(nameOrHash);
    } else {
      this.params = { operator: 'to have ' + singular + ' ' + i(nameOrHash) + ' with value ' + i(value) };
      allRelevantAttributes.should.have.property(nameOrHash, value);
    }
  }

  var browserTagCaseIndependentHtml = function (html) {
    return $('<div/>').append(html).html();
  };

  var addJqPredicateAssertion = function (predicate, nameOverride, operatorOverride) {
    Assertion.add(nameOverride || predicate, function() {
      this.params = { operator: 'to be ' + (operatorOverride || predicate) };
      this.assert($(this.obj).is(':' + predicate));
    }, true);
  }

  Assertion.add('className', function(className) {
    this.params = { operator: 'to have class ' + className };
    this.assert($(this.obj).hasClass(className));
  });

  Assertion.add('css', function(css) {
    this.params = { operator: 'to have css ' + i(css) };
    for (var prop in css) {
      var value = css[prop];
      if (value === 'auto' && $(this.obj).get(0).style[prop] === 'auto') {
        continue;
      }
      $(this.obj).css(prop).should.eql(value);
    }
  });

  addJqPredicateAssertion('visible');
  addJqPredicateAssertion('hidden');
  addJqPredicateAssertion('selected');
  addJqPredicateAssertion('checked');
  addJqPredicateAssertion('disabled');
  addJqPredicateAssertion('empty', 'emptyJq');
  addJqPredicateAssertion('focus', 'focused', 'focused');

  Assertion.add('inDOM', function() {
    this.params = { operator: 'to be in the DOM' };
    this.assert($.contains(document.documentElement, $(this.obj)[0]));
  }, true);

  Assertion.add('exist', function() {
    this.params = { operator: 'to exist' };
    $(this.obj).should.not.have.length(0);
  }, true);

  Assertion.add('attr', function() {
    var args = [
      'attr',
      'attribute',
      'attributes'
    ].concat(Array.prototype.slice.call(arguments, 0));
    jQueryAttributeTestHelper.apply(this, args);
  });

  Assertion.add('prop', function() {
    var args = [
      'prop',
      'property',
      'properties'
    ].concat(Array.prototype.slice.call(arguments, 0));
    jQueryAttributeTestHelper.apply(this, args);
  });

  Assertion.add('elementId', function(id) {
    this.params = { operator: 'to have ID ' + i(id) };
    this.obj.should.have.attr('id', id);
  });

  Assertion.add('html', function(html) {
    this.params = { operator: 'to have HTML ' + i(html) };
    $(this.obj).html().should.eql(browserTagCaseIndependentHtml(html));
  });

  Assertion.add('containHtml', function(html) {
    this.params = { operator: 'to contain HTML ' + i(html) };
    $(this.obj).html().indexOf(browserTagCase
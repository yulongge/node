// Generated by LiveScript 1.4.0
var ditto, last, o, bnf, operators, tokens, name, alts, alt, token;
ditto = {};
last = '';
o = function(patterns, action, options){
  patterns = patterns.trim().split(/\s+/);
  action && (action = action === ditto
    ? last
    : (action + "").replace(/^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/, function(arg$, a){
      return "$$ = " + ('L(' === a.slice(0, 2)
        ? '('
        : "L(@1, @" + patterns.length + ",") + a + ");";
    }).replace(/\b(?!Er)(?!String)[A-Z][\w.]*/g, 'yy.$&').replace(/(\.L\()\s*(\d+\s*\,)\s*(\d+\s*\,)?/g, function(arg$, a, b, c){
      return a + "@" + (b || '1,') + "@" + (c || b || patterns.length + ",");
    }));
  return [patterns, last = action || '', options];
};
bnf = {
  Chain: [
    o('ID', function(){
      return Chain(L(1, Var($1)));
    }), o('Parenthetical', function(){
      return Chain($1);
    }), o('List', ditto), o('STRNUM', function(){
      return Chain(L(1, Literal($1)));
    }), o('LITERAL', ditto), o('Chain DOT Key', function(){
      return $1.add(L(2, 3, Index($3, $2, true)));
    }), o('Chain DOT List', ditto), o('Chain CALL( ArgList OptComma )CALL', function(){
      return $1.add(L(2, 5, Call($3)));
    }), o('Chain ?', function(){
      return Chain(L(1, 2, Existence($1.unwrap())));
    }), o('LET CALL( ArgList OptComma )CALL Block', function(){
      return Chain(L(1, 5, Call['let']($3, $6)));
    }), o('[ Expression LoopHeads ]', function(){
      return Chain(L(1, 4, $3[0].makeComprehension($2, $3.slice(1))));
    }), o('[ Expression LoopHeads DEDENT ]', function(){
      return Chain(L(1, 5, $3[0].makeComprehension($2, $3.slice(1))));
    }), o('{ [ ArgList OptComma ] LoopHeads }', function(){
      return Chain(L(1, 7, $6[0].addObjComp().makeComprehension(L(3, Arr($3)), $6.slice(1))));
    }), o('( BIOP )', function(){
      return Chain(L(2, Binary($2)));
    }), o('( BIOP Expression )', function(){
      return Chain(L(2, Binary($2, void 8, $3)));
    }), o('( Expression BIOP )', function(){
      return Chain(L(3, Binary($3, $2)));
    }), o('( BIOPR )', function(){
      return Chain(L(2, '!' === $2.charAt(0)
        ? Binary($2.slice(1)).invertIt()
        : Binary($2)));
    }), o('( BIOPR Expression )', function(){
      return Chain(L(2, '!' === $2.charAt(0)
        ? Binary($2.slice(1), void 8, $3).invertIt()
        : Binary($2, void 8, $3)));
    }), o('( Expression BIOPR )', function(){
      return Chain(L(3, '!' === $3.charAt(0)
        ? Binary($3.slice(1), $2).invertIt()
        : Binary($3, $2)));
    }), o('( BIOPBP )', function(){
      return Chain(L(2, Binary($2)));
    }), o('( BIOPBP CALL( ArgList OptComma )CALL )', function(){
      return Chain(L(2, Binary($2, void 8, $4)));
    }), o('( BIOPP )', function(){
      return Chain(L(2, Binary($2)));
    }), o('( PARAM( ArgList OptComma )PARAM BIOPP )', function(){
      return Chain(L(6, Binary($6, $3)));
    }), o('( UNARY )', function(){
      return Chain(L(2, Unary($2)));
    }), o('( CREMENT )', ditto), o('( BACKTICK Chain BACKTICK )', function(){
      return Chain($3);
    }), o('( Expression BACKTICK Chain BACKTICK )', function(){
      return Chain(L(2, 5, $4.add(L(2, Call([$2])))));
    }), o('( BACKTICK Chain BACKTICK Expression )', function(){
      return Chain(L(3, Chain(Var('flip$'))).add(L(3, Call([$3])))).flipIt().add(L(5, Call([$5])));
    }), o('[ Expression TO Expression ]', function(){
      return Chain(L(2, 4, new For({
        from: $2,
        op: $3,
        to: $4,
        inComprehension: true
      })));
    }), o('[ Expression TO Expression BY Expression ]', function(){
      return Chain(L(2, 6, new For({
        from: $2,
        op: $3,
        to: $4,
        step: $6,
        inComprehension: true
      })));
    }), o('[ TO Expression ]', function(){
      return Chain(L(2, 3, new For({
        from: Chain(Literal(0)),
        op: $2,
        to: $3,
        inComprehension: true
      })));
    }), o('[ TO Expression BY Expression ]', function(){
      return Chain(L(2, 5, new For({
        from: Chain(Literal(0)),
        op: $2,
        to: $3,
        step: $5,
        inComprehension: true
      })));
    }), o('Chain DOT [ Expression TO Expression BY Expression ]', function(){
      return Chain(L(1, 9, new StepSlice({
        op: $5,
        target: $1,
        from: $4,
        to: $6,
        step: $8
      })));
    }), o('Chain DOT [ TO Expression BY Expression ]', function(){
      return Chain(L(1, 8, new StepSlice({
        op: $4,
        target: $1,
        from: Literal(0),
        to: $5,
        step: $7
      })));
    }), o('Chain DOT [ Expression TO Expression ]', function(){
      return Chain(L(1, 7, Slice({
        type: $5,
        target: $1,
        from: $4,
        to: $6
      })));
    }), o('Chain DOT [ Expression TO ]', function(){
      return Chain(L(1, 6, Slice({
        type: $5,
        target: $1,
        from: $4
      })));
    }), o('Chain DOT [ TO Expression ]', function(){
      return Chain(L(1, 6, Slice({
        type: $4,
        target: $1,
        to: $5
      })));
    }), o('Chain DOT [ TO ]', function(){
      return Chain(L(1, 5, Slice({
        type: $4,
        target: $1
      })));
    }), o('WITH Expression Block', function(){
      return Chain(L(1, 2, Cascade($2, $3, 'with')));
    }), o('FOR  Expression Block', function(){
      return Chain(L(1, 2, new For({
        kind: $1,
        source: $2,
        body: $3,
        ref: true
      }).addBody($3)));
    })
  ],
  List: [
    o('[ ArgList    OptComma ]', function(){
      return Arr($2);
    }), o('{ Properties OptComma }', function(){
      return Obj($2);
    }), o('[ ArgList    OptComma ] LABEL', function(){
      return Arr($2).named($5);
    }), o('{ Properties OptComma } LABEL', function(){
      return Obj($2).named($5);
    })
  ],
  Key: [o('KeyBase'), o('Parenthetical')],
  KeyBase: [
    o('ID', function(){
      return Key($1);
    }), o('STRNUM', function(){
      return Literal($1);
    })
  ],
  ArgList: [
    o('', function(){
      return [];
    }), o('Arg', function(){
      return [$1];
    }), o('ArgList , Arg', function(){
      return $1.concat($3);
    }), o('ArgList OptComma NEWLINE Arg', function(){
      return $1.concat($4);
    }), o('ArgList OptComma INDENT ArgList OptComma DEDENT', ditto)
  ],
  Arg: [
    o('Expression'), o('... Expression', function(){
      return Splat($2);
    }), o('...', function(){
      return Splat(L(1, Arr()), true);
    })
  ],
  OptComma: [o(''), o(',')],
  Lines: [
    o('', function(){
      return Block();
    }), o('Line', function(){
      return Block($1);
    }), o('Lines NEWLINE Line', function(){
      return $1.add($3);
    }), o('Lines NEWLINE')
  ],
  Line: [
    o('Expression'), o('Expression Block', function(){
      return Cascade($1, $2, 'cascade');
    }), o('PARAM( ArgList OptComma )PARAM <- Expression', function(){
      return Call.back($2, $6, /~/.test($5), /--|~~/.test($5), /!/.test($5), /\*/.test($5));
    }), o('COMMENT', function(){
      return JS($1, true, true);
    }), o('...', function(){
      return Throw(L(1, JS("Error('unimplemented')")));
    }), o('REQUIRE Chain', function(){
      return Require($2.unwrap());
    })
  ],
  Block: [o('INDENT Lines DEDENT', function(){
    return $2;
  })],
  Expression: [
    o('Chain CLONEPORT Expression', function(){
      return Import(L(1, 2, Unary('^^', $1, {
        prec: 'UNARY'
      })), $3, false);
    }), o('Chain CLONEPORT Block', function(){
      return Import(L(1, 2, Unary('^^', $1, {
        prec: 'UNARY'
      })), $3.unwrap(), false);
    }), o('Expression BACKTICK Chain BACKTICK Expression', function(){
      return $3.add(L(1, 5, Call([$1, $5])));
    }), o('Chain', function(){
      return $1.unwrap();
    }), o('Chain ASSIGN Expression', function(){
      return Assign($1.unwrap(), $3, L(2, Box($2)));
    }), o('Chain ASSIGN INDENT ArgList OptComma DEDENT', function(){
      return Assign($1.unwrap(), Arr.maybe($4), L(2, Box($2)));
    }), o('Expression IMPORT Expression', function(){
      return Import($1, $3, $2 === '<<<<');
    }), o('Expression IMPORT INDENT ArgList OptComma DEDENT', function(){
      return Import($1, Arr.maybe($4), $2 === '<<<<');
    }), o('CREMENT Chain', function(){
      return Unary($1, $2.unwrap());
    }), o('Chain CREMENT', function(){
      return Unary($2, $1.unwrap(), true);
    }), o('UNARY ASSIGN Chain', function(){
      return Assign($3.unwrap(), [$1], L(2, Box($2)));
    }), o('+-    ASSIGN Chain', ditto), o('CLONE ASSIGN Chain', ditto), o('UNARY Expression', function(){
      return Unary($1, $2);
    }), o('+-    Expression', ditto, {
      prec: 'UNARY'
    }), o('CLONE Expression', ditto, {
      prec: 'UNARY'
    }), o('UNARY INDENT ArgList OptComma DEDENT', function(){
      return Unary($1, Arr.maybe($3));
    }), o('YIELD', function(){
      return Yield($1);
    }), o('YIELD Expression', function(){
      return Yield($1, $2);
    }), o('Expression +-      Expression', function(){
      return L(2, Binary($2, $1, $3));
    }), o('Expression COMPARE Expression', ditto), o('Expression LOGIC   Expression', ditto), o('Exp
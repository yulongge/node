/*global require:true */
var hooker = require('../lib/hooker');

exports['hook'] = {
  setUp: function(done) {
    this.order = [];
    this.track = function() {
      [].push.apply(this.order, arguments);
    };

    this.prop = 1;
    this.add = function(a, b) {
      this.track("add", this.prop, a, b);
      return this.prop + a + b;
    };

    this.obj = {
      that: this,
      prop: 1,
      add1: function(a, b) {
        this.that.track("add1", this.prop, a, b);
        return this.prop + a + b;
      },
      add2: function(a, b) {
        this.that.track("add2", this.prop, a, b);
        return this.prop + a + b;
      },
      add3: function(a, b) {
        this.that.track("add3", this.prop, a, b);
        return this.prop + a + b;
      }
    };

    done();
  },
  'orig': function(test) {
    test.expect(1);
    var orig = this.add;
    hooker.hook(this, "add", function() {});
    test.strictEqual(hooker.orig(this, "add"), orig, "should return a refernce to the original function.");
    test.done();
  },
  'once': function(test) {
    test.expect(5);
    var orig = this.add;
    hooker.hook(this, "add", {
      once: true,
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track("before", this.prop, a, b);
      }
    });
    test.strictEqual(this.add(2, 3), 6, "should return the original function's result.");
    test.deepEqual(this.order, ["before", 1, 2, 3, "add", 1, 2, 3], "functions should execute in-order.");
    test.strictEqual(this.add, orig, "should automatically unhook when once is specified.");
    this.order = [];
    test.strictEqual(this.add(2, 3), 6, "should return the original function's result.");
    test.deepEqual(this.order, ["add", 1, 2, 3], "only the original function should execute.");
    test.done();
  },
  'pre-hook (simple syntax)': function(test) {
    test.expect(3);
    // Pre-hook.
    var result = hooker.hook(this, "add", function(a, b) {
      // Arguments are passed into pre-hook as specified.
      this.track("before", this.prop, a, b);
    });
    test.deepEqual(result, ["add"], "add should have been hooked.");
    test.strictEqual(this.add(2, 3), 6, "should return the original function's result.");
    test.deepEqual(this.order, ["before", 1, 2, 3, "add", 1, 2, 3], "functions should execute in-order.");
    test.done();
  },
  'pre-hook': function(test) {
    test.expect(3);
    // Pre-hook.
    var result = hooker.hook(this, "add", {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track("before", this.prop, a, b);
      }
    });
    test.deepEqual(result, ["add"], "add should have been hooked.");
    test.strictEqual(this.add(2, 3), 6, "should return the original function's result.");
    test.deepEqual(this.order, ["before", 1, 2, 3, "add", 1, 2, 3], "functions should execute in-order.");
    test.done();
  },
  'post-hook': function(test) {
    test.expect(3);
    // Post-hook.
    var result = hooker.hook(this, "add", {
      post: function(result, a, b) {
        // Arguments to post-hook are the original function's return value,
        // followed by the specified function arguments.
        this.track("after", this.prop, a, b, result);
      }
    });
    test.deepEqual(result, ["add"], "add should have been hooked.");
    test.strictEqual(this.add(2, 3), 6, "should return the original function's result.");
    test.deepEqual(this.order, ["add", 1, 2, 3, "after", 1, 2, 3, 6], "functions should execute in-order.");
    test.done();
  },
  'pre- & post-hook': function(test) {
    test.expect(2);
    // Pre- & post-hook.
    hooker.hook(this, "add", {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track("before", this.prop, a, b);
      },
      post: function(result, a, b) {
        // Arguments to post-hook are the original function's return value,
        // followed by the specified function arguments.
        this.track("after", this.prop, a, b, result);
      }
    });
    test.strictEqual(this.add(2, 3), 6, "should return the original function's result.");
    test.deepEqual(this.order, ["before", 1, 2, 3, "add", 1, 2, 3, "after", 1, 2, 3, 6], "functions should execute in-order.");
    test.done();
  },

  'pre-hook, return value override': function(test) {
    test.expect(2);
    // Pre-hook.
    hooker.hook(this, "add", {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track("before", this.prop, a, b);
        // This return value will override the original function's return value.
        return hooker.override("b" + this.prop + a + b);
      }
    });
    test.strictEqual(this.add(2, 3), "b123", "should return the overridden result.");
    test.deepEqual(this.order, ["before", 1, 2, 3, "add", 1, 2, 3], "functions should execute in-order.");
    test.done();
  },
  'post-hook, return value override': function(test) {
    test.expect(2);
    // Post-hook.
    hooker.hook(this, "add", {
      post: function(result, a, b) {
        // Arguments to post-hook are the original function's return value,
        // followed by the specified function arguments.
        this.track("after", this.prop, a, b, result);
        // This return value will override the original function's return value.
        return hooker.override("a" + this.prop + a + b + result);
      }
    });
    test.strictEqual(this.add(2, 3), "a1236", "should return the post-hook overridden result.");
    test.deepEqual(this.order, ["add", 1, 2, 3, "after", 1, 2, 3, 6], "functions should execute in-order.");
    test.done();
  },
  'pre- & post-hook, return value override': function(test) {
    test.expect(2);
    // Pre- & post-hook.
    hooker.hook(this, "add", {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track("before", this.prop, a, b);
        // This return value will override the original function's return value.
        return hooker.override("b" + this.prop + a + b);
      },
      post: function(result, a, b) {
        // Arguments
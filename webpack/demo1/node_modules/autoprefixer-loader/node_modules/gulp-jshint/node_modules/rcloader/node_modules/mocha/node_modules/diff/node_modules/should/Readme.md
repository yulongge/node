_should_ is an expressive, readable, test framework agnostic, assertion library for [node](http://nodejs.org).

It extends the Object prototype with a single non-enumerable getter that allows you to express how that object should behave.

_should_ literally extends node's _assert_ module, in fact, it is node's assert module, for example `should.equal(str, 'foo')` will work, just as `assert.equal(str, 'foo')` would, and `should.AssertionError` **is** `assert.AssertionError`, meaning any test framework supporting this constructor will function properly with _should_.

## Example
```javascript
var user = {
    name: 'tj'
  , pets: ['tobi', 'loki', 'jane', 'bandit']
};

user.should.have.property('name', 'tj');
user.should.have.property('pets').with.lengthOf(4);

someAsyncTask(foo, function(err, result){
  should.not.exist(err);
  should.exist(result);
  result.bar.should.equal(foo);
});
```
## Installation

    $ npm install should

## assert extras

As mentioned above, _should_ extends node's _assert_. The returned object from `require('should')` is thus similar to the returned object from `require('assert')`, but it has one extra convenience method:
```javascript
should.exist('hello')
should.exist([])
should.exist(null)  // will throw
```
This is equivalent to `should.ok`, which is equivalent to `assert.ok`, but reads a bit better. It gets better, though:
```javascript
should.not.exist(false)
should.not.exist('')
should.not.exist({})    // will throw
```
We may add more _assert_ extras in the future... ;)

## chaining assertions

Some assertions can be chained, for example if a property is volatile we can first assert property existence:
```javascript
user.should.have.property('pets').with.lengthOf(4)
```
which is essentially equivalent to below, however the property may not exist:
```javascript
user.pets.should.have.lengthOf(4)
```
our dummy getters such as _and_ also help express chaining:
```javascript
user.should.be.a('object').and.have.property('name', 'tj')
```
## exist (static)

The returned object from `require('should')` is the same object as `require('assert')`. So you can use `should` just like `assert`:
```javascript
should.fail('expected an error!')
should.strictEqual(foo, bar)
```
In general, using the Object prototype's _should_ is nicer than using these `assert` equivalents, because _should_ gives you access to the expressive and readable language described above:
```javascript
foo.should.equal(bar)   // same as should.strictEqual(foo, bar) above
```
The only exception, though, is when you can't be sure that a particular object exists. In that case, attempting to access the _should_ property may throw a TypeError:
```javascript
foo.should.equal(bar)   // throws if foo is null or undefined!
```
For this case, `require('should')` extends `require('assert')` with an extra convenience method to check whether an object exists:
```javascript
should.exist({})
should.exist([])
should.exist('')
should.exist(0)
should.exist(null)      // will throw
should.exist(undefined) // will throw
```
You can also check the 
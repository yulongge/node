'use strict';

var PassThrough = require('readable-stream/passthrough');
var split = require('split');
var trim = require('trim');
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var reemit = require('re-emitter');

var expr = require('./lib/utils/regexes');
var parseLine = require('./lib/parse-line');

function Parser() {
  if (!(this instanceof Parser)) {
    return new Parser();
  }

  EventEmitter.call(this);

  this.results = {
    tests: [],
    asserts: [],
    versions: [],
    results: [],
    comments: [],
    pass: [],
    fail: [],
  };
  this.testNumber = 0;

  this.previousLine = '';
  this.writingErrorOutput = false;
  this.writingErrorStackOutput = false;
  this.tmpErrorOutput = '';
}

util.inherits(Parser, EventEmitter);

Parser.prototype.handleLine = function handleLine(line) {

  var parsed = parseLine(line);

  // This will handle all the error stuff
  this._handleError(line);

  // This is weird, but it's the only way to distinguish a
  // console.log type output from an error output
  if (
    !this.writingErrorOutput
    && !parsed
    && !isErrorOutputEnd(line)
    && !isRawTapTestStatus(line)
    )
      {
          var comment = {
            type: 'comment',
            raw: line,
            test: this.testNumber
          };
          this.emit('comment', comment);
          this.results.comments.push(comment);
      }

  // Invalid line
  if (!parsed) {
    return;
  }

  // Handle tests
  if (parsed.type === 'test') {
    this.testNumber += 1;
    pa
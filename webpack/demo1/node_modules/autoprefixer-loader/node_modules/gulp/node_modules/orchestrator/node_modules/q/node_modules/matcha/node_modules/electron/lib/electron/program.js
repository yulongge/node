/*!
 * Electron - process.argv parsing
 * Copyright (c) 2012 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * External dependancies
 */

var Drip = require('drip')
  , tty = require('tty')
  , util = require('util');

/*!
 * Electron dependancies
 */

var Args = require('./args')
  , Command = require('./command')
  , themes = require('./themes');

/*!
 * isTTY (can support color)
 */

var istty = tty.isatty(1) && tty.isatty(2);

/*!
 * defaults (a, b)
 *
 * Helper function to merge one object to another
 * using the first object as default values.
 *
 * @param {Object} subject
 * @param {Object} defaults
 * @name defaults
 * @api private
 */

function defaults (a, b) {
  if (a && b) {
    for (var key in b) {
      if ('undefined' == typeof a[key]) a[key] = b[key];
    }
  }
  return a;
};

/*!
 * Main export
 */

module.exports = Program;

/**
 * ## Program Framework
 *
 * The primary export of the electron module is a function
 * that composes a new program framework. The returned
 * `program` is a chainable api that allow you to change
 * settings, define commands, and start launch the program.
 *
 * The primary argument provided on construction is the base
 * name used through the help documentation. In a majority of
 * of cases, this would be the command executed from your terminal
 * used launch the program.
 *
 * In the case of scripts with the header of `#!/usr/bin/env node`,
 * you should use a variant of the following.
 *
 *     var program = electron('microscope');
 *
 * If you are however launching your program from a `.js` file,
 * the recommended construction pattern is the following.
 *
 *     var program = electrong('node microscope.js');
 *
 * You can then chain any of the following commands to further
 * define your application and commands.
 *
 * @header Program Framework
 */

function Program (base, opts) {
  /*!
   * @param {String} base name
   * @param {Object} options
   */

  Drip.call(this, { delimeter: ' ' });
  this.commands = [];
  this._colorized = false;
  this.opts = defaults(opts || {}, {
      useColors: istty
    , version: null
    , desc: null
    , name: base || 'Electron'
    , base: base || 'electron'
    , cwd: process.cwd()
    , theme: {
          name: 'clean'
        , spec: {
            noColor: false
          }
      }
  });
}

/*!
 * Inherit from Drip event emitter.
 */

util.inherits(Program, Drip);

/**
 * ### .command (name)
 *
 * The most important aspect of an application is defining
 * the different commands that can be executed for it. Some
 * people prefer a CLI tool that does one thing based on a
 * set of options. Others prefer a command line tool that
 * can pivot based on a command string. Electron supports both.
 *
 * When using the `command` method, it will return a constructed
 * command object with a different set of methods for chaining.
 * Please read the "Constructing Commands" section for all available
 * chainable methods and their respective purpose.
 *
 * ##### Single Command
 *
 * As you understand how Electron parses command-line options,
 * you know that a command is any option that does
 * not start with `-` or `--`. Therefor, a single-command electron
 * application is one that does not require any `commands`, but
 * will execute a single action. Best demonstrated...
 *
 *     $ node app.js -p 8080
 *
 * In the case of single-command applications, we will define
 * a `default` command for electron to run.
 *
 *     program
 *       .command('default')
 *       .action(function (argv) {
 *         var port = argv.param('p', 'port');
 *         // something cool
 *       });
 *
 * The `default` command will run when no commands are passed in,
 * but it will not run if a command is provided.
 *
 * ##### Multiple Commands
 *
 * You can also create many different commands for your application
 * based on a simple string. These can be used in conjunction
 * with `default` if you would like.
 *
 *     $ node app.js hello --universe
 *
 * In this case we want to only run an action when the comamnd
 * `hello` is present. This can easily be achieved.
 *
 *     program
 *       .command('hello')
 *       .action(fn);
 *
 * There are also cases where you might want to have multipe layers
 * of commands.
 *
 *     $ node app.js hello universe
 *
 * Using the same mechanism, we can easily define this action.
 *
 *     program
 *       .command('hello universe')
 *       .action(fn);
 *
 * One final option to explore with multiple commands is wildcards.
 * Wildcards can exist at any level in a multi-word command, but they
 * only work for entire words, not substrings.
 *
 *     program
 *       .command('hello *')
 *       .action(function (argv) {
 *         var where = argv.commands[1];
 *       });
 *
 * Would respond for any command starting with `hello` and is two
 * commands long, such as...
 *
 *     $ node app.js hello world
 *     $ node app.js hello universe
 *
 * ##### Absent Commands
 *
 * Should you want to notify your users when they attempt to use
 * a command is not support, you may use the `absent` command. This
 * is also useful if you want to have a single command app but
 * support a list of items as "options", such as a list of files or
 * directories.
 *
 *     $ node build.js file1.js files2.js
 *
 *     program
 *       .command('absent')
 *       .action(function (argv) {
 *         var files = argv.commands.slice(0);
 *         // something cool
 *       });
 *
 * @param {String} command name
 * @returns chainable constructed command
 * @name command
 * @api public
 */

Program.prototype.command = function (name) {
  var cmd = new Command(name);
  this.commands.push(cmd);
  return cmd;
};

/**
 * ### .parse (process.argv)
 *
 * The `parse` method will initiate the program with
 * selection of arguments and run a matching action. It
 * should be used once all commands and settings have
 * been propogated.
 *
 *     program.parse();
 *     program.parse(process.argv);
 *     program.parse([ 'node', 'app.js', '--hello', '--universe' ]);
 *
 * If no parameter is provided, `parse` will default to using
 * the current processes `p
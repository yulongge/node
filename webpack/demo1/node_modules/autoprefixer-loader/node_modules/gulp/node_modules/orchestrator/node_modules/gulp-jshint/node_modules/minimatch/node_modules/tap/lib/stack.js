exports.capture = capture
exports.captureString = captureString
exports.at = at
exports.parseLine = parseLine
exports.clean = clean

var cwd = process.cwd()
// var methods =[
//   'getThis',
//   'getFunction',
//   'getTypeName',
//   'getFunctionName',
//   'getMethodName',
//   'getFileName',
//   'getLineNumber',
//   'getColumnNumber',
//   'getEvalOrigin',
//   'isToplevel',
//   'isEval',
//   'isNative',
//   'isConstructor'
// ]

function clean (stack) {
  if (!Array.isArray(stack))
    stack = stack.split('\n')

  var internals = [
    /\(domain.js:[0-9]+:[0-9]+\)$/,
    /\(events.js:[0-9]+:[0-9]+\)$/,
    /\(node.js:[0-9]+:[0-9]+\)$/,
    /\(timers.js:[0-9]+:[0-9]+\)$/,
    /\(module.js:[0-9]+:[0-9]+\)$/,
    /GeneratorFunctionPrototype.next \(native\)/,
    /node_modules[\\\/]tap[\\\/](.*?)\.js:[0-9]:[0-9]\)?$/
  ]

  if (!(/^\s*at /.test(stack[0])) &&
       (/^\s*at /.test(stack[1])))
    stack = stack.slice(1)

  stack = stack.map(function (st) {
    if (internals.some(function (internal) {
      return internal.test(st)
    })) {
      return null
    }
    return st.trim()
      .replace(/^\s*at /, '')
      .replace(cwd + '/', '')
      .replace(cwd + '\\', '')
  }).filter(function (st) {
    return st
  }).join('\n').trim()

  if (stack)
    return stack + '\n'
  else
    return null
}

function captureString (limit, fn) {
  if (typeof limit === 'function') {
    fn = limit
    limit = Infinity
  }
  if (!fn)
    fn = captureString

  var limitBefore = Error.stackTraceLimit
  if (limit)
    E
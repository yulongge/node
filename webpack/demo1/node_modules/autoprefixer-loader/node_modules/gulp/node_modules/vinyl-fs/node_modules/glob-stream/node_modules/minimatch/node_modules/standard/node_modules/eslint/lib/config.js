/**
 * @fileoverview Responsible for loading config files
 * @author Seth McLaughlin
 * @copyright 2014 Nicholas C. Zakas. All rights reserved.
 * @copyright 2013 Seth McLaughlin. All rights reserved.
 * @copyright 2014 Michael McLaughlin. All rights reserved.
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var fs = require("fs"),
    path = require("path"),
    environments = require("../conf/environments"),
    util = require("./util"),
    FileFinder = require("./file-finder"),
    stripComments = require("strip-json-comments"),
    assign = require("object-assign"),
    debug = require("debug"),
    yaml = require("js-yaml"),
    userHome = require("user-home"),
    isAbsolutePath = require("path-is-absolute");

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

var LOCAL_CONFIG_FILENAME = ".eslintrc",
    PACKAGE_CONFIG_FILENAME = "package.json",
    PACKAGE_CONFIG_FIELD_NAME = "eslintConfig",
    PERSONAL_CONFIG_PATH = userHome ? path.join(userHome, LOCAL_CONFIG_FILENAME) : null;

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

var loadedPlugins = Object.create(null);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

debug = debug("eslint:config");

/**
 * Determines if a given string represents a filepath or not using the same
 * conventions as require(), meaning that the first character must be nonalphanumeric
 * and not the @ sign which is used for scoped packages to be considered a file path.
 * @param {string} filePath The string to check.
 * @returns {boolean} True if it's a filepath, false if not.
 * @private
 */
function isFilePath(filePath) {
    return isAbsolutePath(filePath) || !/\w|@/.test(filePath[0]);
}

/**
 * Load and parse a JSON config object from a file.
 * @param {string} filePath the path to the JSON config file
 * @returns {Object} the parsed config object (empty object if there was a parse error)
 * @private
 */
function loadConfig(filePath) {
    var config = {};

    if (filePath) {

        if (isFilePath(filePath)) {
            try {
                config = yaml.safeLoad(stripComments(fs.readFileSync(filePath, "utf8"))) || {};
            } catch (e) {
                debug("Error reading YAML file: " + filePath);
                e.message = "Cannot read config file: " + filePath + "\nError: " + e.message;
                throw e;
            }

        } else {

            // it's a package
            if (filePath.indexOf("eslint-config-") === -1) {
                if (filePath.indexOf("@") === 0) {
                    // for scoped packages, insert the eslint-config after the last /
                    filePath = filePath.replace(/(.*\/)([^\/]+)/, "$1eslint-config-$2");
                } else {
                    filePath = "eslint-config-" + filePath;
                }
            }

            var packagedConfig = require(filePath);
        }

        if (packagedConfig) {
            assign(config, packagedConfig);
        }

        // If an `extends` property is defined, it represents a configuration file to use as
        // a "parent". Load the referenced file and merge the configuration recursively.
        if (config.extends) {

            var parentPath = config.extends;
            if (isFilePath(parentPath)) {
                // If the `extends` path is relative, use the directory of the current configuration
                // file as the reference point. Otherwise, use as-is.
                parentPath = (!isAbsolutePath(parentPath) ?
                    path.join(path.dirname(filePath), parentPath) :
                    parentPath
                );
            }

            // Merge the configuration, ensuring children get preference over the parent
            try {
                config = util.mergeConfigs(loadConfig(parentPath), config);
            } catch (e) {
                // If the file referenced by `extends` failed to load, add the path to the
                // configuration file that referenced it to the error message so the user is
                // able to see where it was referenced from, then re-throw
                e.message += "\nReferenced from: " + filePath;
                throw e;
            }
        }


    }


    return config;
}

/**
 * Load configuration for all plugins provided.
 * @param {string[]} pluginNames An array of plugin names which should be loaded.
 * @returns {Object} all plugin configurations merged together
 */
function getPluginsConfig(pluginNames) {
    var pluginConfig = {};

    if (pluginNames) {
        pluginNames.forEach(function (pluginName) {
            var pluginNamespace = util.getNamespace(pluginName),
                pluginNameWithoutNamespace = util.removeNameSpace(pluginName),
                pluginNameWithoutPrefix = util.removePluginPrefix(pluginNameWithoutNamespace),
                plugin = {},
                rules = {};

            if (!loadedPlugins[pluginNameWithoutPrefix]) {
                try {
                    plugin = require(pluginNamespace + util.PLUGIN_NAME_PREFIX + pluginNameWithoutPrefix);
                    loadedPlugins[pluginNameWithoutPrefix] = plugin;
                } catch(err) {
                    debug("Failed to load plugin configuration for " + pluginNameWithoutPrefix + ". Proceeding without it.");
                    plugin = { rulesConfig: {}};
                }
            } else {
                plugin = loadedPlugins[pluginNameWithoutPrefix];
            }

            if (!plugin.rulesConfig) {
                plugin.rulesConfig = {};
            }

            Object.keys(plugin.rulesConfig).forEach(function(item) {
                rules[pluginNameWithoutPrefix + "/" + item] = plugin.rulesConfig[item];
            });

            pluginConfig = util.mergeConfigs(pluginConfig, rules);
        });
    }

    return {rules: pluginConfig};
}

/**
 * Get personal config object from ~/.eslintrc.
 * @returns {Object} the personal config object (empty object if there is no personal config)
 * @private
 */
function getPersonalConfig() {
    var config = {};

    if (PERSONAL_CONFIG_PATH && fs.existsSync(PERSONAL_CONFIG_PATH)) {
        debug("Using personal config");
        config = loadConfig(PERSONAL_CONFIG_PATH);
    }

    return config;
}

/**
 * Get a local config object.
 * @param {Object} thisConfig A Config object.
 * @param {string} directory The directory to start looking in for a local config file.
 * @returns {Object} The local config object, or an empty object if there is no local config.
 */
function getLocalConfig(thisConfig, directory) {
    var found,
        i,
        localConfig,
        localConfigFile,
        config = {},
        localConfigFiles = thisConfig.findLocalConfigFiles(directory),
        numFiles = localConfigFiles.length;

    for (i = 0; i < numFiles; i++) {

        localConfigFile = localConfigFiles[i];

        // Don't consider the personal config file in the home directory.
        if (localConfigFile === PERSONAL_CONFIG_PATH) {
            continue;
        }

        debug("Loading " + localConfigFile);
        localConfig = loadConfig(localConfigFile);

        if (path.basename(localConfigFile) !== LOCAL_CONFIG_FILENAME) {

            // Don't consider a local config file found if the package.json doesn't have the eslintConfig field.
            if (!localConfig.hasOwnProperty(PACKAGE_CONFIG_FIELD_NAME)) {
                continue;
            }
            localConfig = localConfig[PACKAGE_CONFIG_FIELD_NAME] || {};
        }

        found = true;
        debug("Using " + localConfigFile);
        config = util.mergeConfigs(localConfig, config);
    }

    // Use the personal config file if there are no other local config files found.
    return found ? config : util.mergeConfigs(config, getPersonalConfig());
}

/**
 * Creates an environment config based on the specified environments.
 * @param {Object<string,boolean>} envs The environment settings.
 * @param {boolean} reset The value of the command line reset option. If true,
 *      rules are not automatically merged into the config.
 * @returns {Object} A configuration object with the appropriate rules and globals
 *      set.
 * @private
 */
function createEnvironmentConfig(envs, reset) {

    var envConfig = {
        globals: {},
        env: envs || {},
        rules: {},
        ecmaFeatures: {}
    };

    if (envs) {
        Object.keys(envs).filter(function (name) {
            return envs[name];
        }).forEach(function(name) {
            var environment = environments[name];

            if (environment) {

                if (!reset && environment.rules) {
                    assign(envConfig.rules, environment.rules);
                }

                if (environment.globals) {
                    assign(envConfig.globals, environment.globals);
                }

                if (environment.ecmaFeatures) {
                    assign(envConfig.ecmaFeatures, environment.ecmaFeatures);
                }
            }
        });
    }

    return envConfig;
}

//------------------------------------------------------------------------------
// API
//------------------------------------------------------------------------------

/**
 * Config
 * @cons
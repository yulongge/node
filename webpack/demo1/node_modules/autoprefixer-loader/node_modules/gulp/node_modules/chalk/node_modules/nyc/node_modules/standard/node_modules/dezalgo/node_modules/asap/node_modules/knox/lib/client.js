"use strict";

/*!
 * knox - Client
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Emitter = require('events').EventEmitter
  , debug = require('debug')('knox')
  , utils = require('./utils')
  , auth = require('./auth')
  , http = require('http')
  , https = require('https')
  , url = require('url')
  , mime = require('mime')
  , fs = require('fs')
  , crypto = require('crypto')
  , xml2js = require('xml2js')
  , StreamCounter = require('stream-counter')
  , qs = require('querystring');

// The max for multi-object delete, bucket listings, etc.
var BUCKET_OPS_MAX = 1000;

// http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html
var MIN_BUCKET_LENGTH = 3;
var MAX_NON_US_STANDARD_BUCKET_LENGTH = 63;
var MAX_US_STANDARD_BUCKET_LENGTH = 255;
var US_STANDARD_BUCKET = /^[A-Za-z0-9\._-]*$/;
var BUCKET_LABEL = /^(?:[a-z0-9][a-z0-9-]*[a-z0-9]|[a-z0-9])$/;
var IPV4_ADDRESS = /^(\d{1,3}\.){3}(\d{1,3})$/;

/**
 * Register event listeners on a request object to convert standard http
 * request events into appropriate call backs.
 * @param {Request} req The http request
 * @param {Function} fn(err, res) The callback function.
 * err - The exception if an exception occurred while sending the http
 *       request (for example if internet connection was lost).
 * res - The http response if no exception occurred.
 * @api private
 */
function registerReqListeners(req, fn){
  var hasCalledBack = false;

  function cleanup() {
    hasCalledBack = true;
    req.removeListener('response', onResponse);
    req.removeListener('error', onError);
  }

  function onResponse(res){
    if (!hasCalledBack) {
      cleanup();
      fn(null, res);
    }
  }

  function onError(err){
    if (!hasCalledBack) {
      cleanup();
      fn(err);
    }
  }

  req.on('response', onResponse);
  req.on('error', onError);
}

function ensureLeadingSlash(filename) {
  return filename[0] !== '/' ? '/' + filename : filename;
}

function removeLeadingSlash(filename) {
  return filename[0] === '/' ? filename.substring(1) : filename;
}

function encodeSpecialCharacters(filename) {
  // Note: these characters are valid in URIs, but S3 does not like them for
  // some reason.
  return encodeURI(filename).replace(/[!'()* ]/g, function (char) {
    return '%' + char.charCodeAt(0).toString(16);
  });
}

function getHeader(headers, headerNameLowerCase) {
  for (var header in headers) {
    if (header.toLowerCase() === headerNameLowerCase) {
      return headers[header];
    }
  }
  return null;
}

function isNotDnsCompliant(bucket) {
  if (bucket.length > MAX_NON_US_STANDARD_BUCKET_LENGTH) {
    return 'is more than ' + MAX_NON_US_STANDARD_BUCKET_LENGTH + ' characters';
  }

  if (IPV4_ADDRESS.test(bucket)) {
    return 'is formatted as an IPv4 address';
  }

  var bucketLabels = bucket.split('.');
  var bucketLabelsAreValid = bucketLabels.every(function (label) {
    return BUCKET_LABEL.test(label);
  });

  if (!bucketLabelsAreValid) {
    return 'does not consist of valid period-separated labels';
  }

  return false;
}

function isInvalid(bucket) {
  if (bucket.length < MIN_BUCKET_LENGTH) {
    return 'is less than ' + MIN_BUCKET_LENGTH + ' characters';
  }
  if (bucket.length > MAX_US_STANDARD_BUCKET_LENGTH) {
    return 'is more than ' + MAX_US_STANDARD_BUCKET_LENGTH + ' characters';
  }

  if (!US_STANDARD_BUCKET.test(bucket)) {
    return 'contains invalid characters';
  }

  return false;
}

function containsPeriod(bucket) {
  return bucket.indexOf('.') !== -1;
}

function autoDetermineStyle(options) {
  if (!options.style && options.secure !== false &&
      containsPeriod(options.bucket)) {
    options.style = 'path';
    return;
  }

  var dnsUncompliance = isNotDnsCompliant(options.bucket);
  if (dnsUncompliance) {
    if (options.style === 'virtualHosted') {
      throw new Error('Cannot use "virtualHosted" style with a ' +
                      'DNS-uncompliant bucket name: "' + options.bucket +
                      '" is ' + dnsUncompliance + '.');
    }

    options.style = 'path';
    return;
  }

  if (!options.style) {
    options.style = 'virtualHosted';
  }
}

/**
 * Get headers needed for Client#copy and Client#copyTo.
 *
 * @param {String} sourceFilename
 * @param {Object} headers
 * @api private
 */

function getCopyHeaders(sourceBucket, sourceFilename, headers) {
  sourceFilename = encodeSpecialCharacters(ensureLeadingSlash(sourceFilename));
  headers = utils.merge({
    Expect: '100-continue'
  }, headers || {});
  headers['x-amz-copy-source'] = '/' + sourceBucket + sourceFilename;
  headers['Content-Length'] = 0; // to avoid Node's automatic chunking if omitted
  return headers;
}


/**
 * Initialize a `Client` with the given `options`.
 *
 * Required:
 *
 *  - `key`     amazon api key
 *  - `secret`  amazon secret
 *  - `bucket`  bucket name string, ex: "learnboost"
 *
 * @param {Object} options
 * @api public
 */

var Client = module.exports = exports = function Client(options) {
  if (!options.key) throw new Error('aws "key" required');
  if (!options.secret) throw new Error('aws "secret" required');
  if (!options.bucket) throw new Error('aws "bucket" required');

  if (options.style && options.style !== 'virtualHosted' &&
      options.style !== 'path') {
    throw new Error('style must be "virtualHosted" or "path"');
  }

  if (options.port !== undefined && isNaN(parseInt(options.port))) {
    throw new Error('port must be a number.');
  }

  var invalidness = isInvalid(options.bucket);
  var dnsUncompliance = isNotDnsCompliant(options.bucket);

  if (invalidness) {
    throw new Error('Bucket name "' + options.bucket + '" ' + invalidness + '.');
  }

  // Save original options, we will need them for Client#copyTo
  this.options = utils.merge({}, options);

  // Make sure we don't override options the user passes in.
  options = utils.merge({}, options);
  autoDetermineStyle(options);

  if (!options.endpoint) {
    if (!options.region || options.region === 'us-standard' || options.region === 'us-east-1') {
      options.endpoint = 's3.amazonaws.com';
      options.region = 'us-standard';
    } else {
      options.endpoint = 's3-' + options.region + '.amazonaws.com';
    }

    if (options.region !== 'us-standard') {
      if (dnsUncompliance) {
        throw new Error('Outside of the us-standard region, bucket names must' +
                        ' be DNS-compliant. The name "' + options.bucket +
                        '" ' + dnsUncompliance + '.');
      }
    }
  } else {
    options.region = undefined;
  }

  var portSuffix = 'undefined' == typeof options.port ? "" : ":" + options.port;
  this.secure = 'undefined' == typeof options.port;

  if (options.style === 'virtualHosted') {
    this.host = options.bucket + '.' + options.endpoint;
    this.urlBase = options.bucket + '.' + options.endpoint + portSuffix;
  } else {
    this.host = options.endpoint;
    this.urlBase = options.endpoint + portSuffix + '/' + options.bucket;
  }

  // HTTP in Node.js < 0.12 is horribly broken, and leads to lots of "socket
  // hang up" errors: https://github.com/LearnBoost/knox/issues/116. See
  // https://github.com/LearnBoost/knox/issues/116#issuecomment-15045187 and
  // https://github.com/substack/hyperquest#rant
  this.agent = false;

  utils.merge(this, options);

  this.url = this.secure ? this.https : this.http;
};

/**
 * Request with `filename` the given `method`, and optional `headers`.
 *
 * @param {String} method
 * @param {String} filename
 * @param {Object} headers
 * @return {ClientRequest}
 * @api private
 */

Client.prototype.request = function(method, filename, headers){
  var options = { hostname: this.host, agent: this.agent, port: this.port }
    , date = new Date
    , headers = headers || {}
    , fixedFilename = encodeSpecialCharacters(ensureLeadingSlash(filename));

  // Default headers
  headers.Date = date.toUTCString()
  if (this.style === 'virtualHosted') {
    headers.Host = this.host;
  }

  if ('undefined' != typeof this.token)
    headers['x-amz-security-token'] = this.token;

  // Authorization header
  headers.Authorization = auth.authorization({
      key: this.key
    , secret: this.secret
    , verb: method
    , date: date
    , resource: auth.canonicalizeResource('/' + this.bucket + fixedFilename)
    , contentType: getHeader(headers, 'content-type')
    , md5: getHeader(headers, 'content-md5') || ''
    , amazonHeaders: auth.canonicalizeHeaders(headers)
  });

  var pathPrefix = this.style === 'path' ? '/' + this.bucket : '';

  // Issue request
  options.method = method;
  options.path = pathPrefix + fixedFilename;
  options.headers = headers;
  var req = (this.secure ? https : http).request(options);
  req.url = this.url(filename);
  debug('%s %s', method, req.url);

  return req;
};

/**
 * PUT data to `filename` with optional `headers`.
 *
 * Example:
 *
 *     // Fetch the size
 *     fs.stat('Readme.md', function(err, stat){
 *      // Create our request
 *      var req = client.put('/test/Readme.md', {
 *          'Content-Length': stat.size
 *        , 'Content-Type': 'text/plain'
 *      });
 *      fs.readFile('Readme.md', function(err, buf
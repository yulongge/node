/*
 * Based in part on Motorola Mobility’s Montage
 * Copyright (c) 2012, Motorola Mobility LLC. All Rights Reserved.
 * 3-Clause BSD License
 * https://github.com/motorola-mobility/montage/blob/master/LICENSE.md
 */
/*global -URL */
/*jshint node:true */

var Require = exports;
var Q = require("q");
var URL = require("url");
var merge = require("./merge");
var Identifier = require("./identifier");

if (!this) {
    throw new Error("Require does not work in strict mode.");
}

var globalEval = eval; // reassigning causes eval to not use lexical scope.

// Non-CommonJS speced extensions should be marked with an "// EXTENSION"
// comment.

Require.makeRequire = function (config) {
    var require;

    // Configuration defaults:
    config = config || {};
    config.location = URL.resolve(config.location || Require.getLocation(), "./");
    config.paths = config.paths || [config.location];
    config.mappings = config.mappings || {}; // EXTENSION
    config.exposedConfigs = config.exposedConfigs || Require.exposedConfigs;
    config.makeLoader = config.makeLoader || Require.makeLoader;
    config.load = config.load || config.makeLoader(config);
    config.makeCompiler = config.makeCompiler || Require.makeCompiler;
    config.compile = config.compile || config.makeCompiler(config);
    config.parseDependencies = config.parseDependencies || Require.parseDependencies;
    config.read = config.read || Require.read;
    config.optimizers = config.optimizers || {};
    config.compilers = config.compilers || {};
    config.translators = config.translators || {};
    config.redirectTable = config.redirectTable || [];

    // Modules: { exports, id, location, directory, factory, dependencies,
    // dependees, text, type }
    var modules = config.modules = config.modules || {};

    // produces an entry in the module state table, which gets built
    // up through loading and execution, ultimately serving as the
    // ``module`` free variable inside the corresponding module.
    function getModuleDescriptor(id) {
        var lookupId = id.toLowerCase();
        if (!has.call(modules, lookupId)) {
            var extension = Identifier.extension(id);
            var type;
            if (
                extension && (
                    has.call(config.optimizers, extension) ||
                    has.call(config.translators, extension) ||
                    has.call(config.compilers, extension)
                )
            ) {
                type = extension;
            } else {
                type = "js";
            }
            var module = {
                id: id,
                extension: extension,
                type: type,
                display: (config.name || config.location) + "#" + id,
                require: makeRequire(id)
            };
            modules[lookupId] = module;
        }
        return modules[lookupId];
    }

    // for preloading modules by their id and exports, useful to
    // prevent wasteful multiple instantiation if a module was loaded
    // in the bootstrapping process and can be trivially injected into
    // the system.
    function inject(id, exports) {
        var module = getModuleDescriptor(id);
        module.exports = exports;
        module.location = URL.resolve(config.location, id);
        module.directory = URL.resolve(module.location, "./");
        module.injected = true;
        module.type = void 0;
        delete module.redirect;
        delete module.mappingRedirect;
    }

    // Ensures a module definition is loaded, compiled, analyzed
    var load = memoize(function (topId, viaId, loading) {
        var module = getModuleDescriptor(topId);
        return Q.try(function () {
            // If not already loaded, already instantiated, or configured as a
            // redirection to another module.
            if (
                module.factory === void 0 &&
                module.exports === void 0 &&
                module.redirect === void 0
            ) {
                return config.load(topId, module);
            }
        })
        .then(function () {
            // Translate (to JavaScript, optionally provide dependency analysis
            // services).
            if (module.type !== "js" && has.call(config.translators, module.type)) {
                var translatorId = config.translators[module.type];
                return Q.try(function () {
                    // The use of a preprocessor package is optional for
                    // translators, though mandatory for optimizers because
                    // there are .js to .js optimizers, but no such
                    // translators.
                    if (config.hasPreprocessorPackage) {
                        return config.loadPreprocessorPackage();
                    } else {
                        return require;
                    }
                })
                .invoke("async", translatorId)
                .then(function (translate) {
                    module.type = "js";
                    return translate(module);
                });
            }
        })
        .then(function () {
            if (module.type === "js" && module.text !== void 0 && module.dependencies === void 0) {
                // Remove the shebang
                module.text = module.text.replace(/^#!/, "//#!");
                // Parse dependencies.
                module.dependencies = config.parseDependencies(module.text);
            }

            // Run optional optimizers.
            // {text, type} to {text', type')
            if (config.hasPreprocessorPackage && has.call(config.optimizers, module.type)) {
                var optimizerId = config.optimizers[module.type];
                return config.loadPreprocessorPackage()
                .invoke("async", optimizerId)
                .then(function (optimize) {
                    return optimize(module);
                });
            }
        })
        .then(function () {
            if (
                module.factory === void 0 &&
                module.redirect === void 0 &&
                module.exports === void 0
            ) {
                // Then apply configured compilers.  module {text, type} to
                // {dependencies, factory || exports || redirect}
                if (has.call(config.compilers, module.type)) {
                    var compilerId = Identifier.resolve(config.compilers[module.type], "");
                    return deepLoad(compilerId, "", loading)
                    .then(function () {
                        var compile = require(compilerId);
                        compile(module);
                    });
                } else if (module.type === "js") {
                    config.compile(module);
                }
            }

            // Final dependency massaging
            var dependencies = module.dependencies = module.dependencies || [];
            if (module.redirect !== void 0) {
                dependencies.push(module.redirect);
            }
            if (module.extraDependencies !== void 0) {
                Array.prototype.push.apply(module.dependencies, module.extraDependencies);
            }
        });

    });

    // Load a module definition, and the definitions of its transitive
    // dependencies
    function deepLoad(topId, viaId, loading) {
        var module = getModuleDescriptor(topId);
        // this is a memo of modules already being loaded so we don’t
        // data-lock on a cycle of dependencies.
        // has this all happened before?  will it happen again?
        loading = loading || {};
        if (has.call(loading, topId)) {
            return Q(); // break the cycle of violence.
        }
        loading[topId] = true; // this has happened before
        return load(topId, viaId)
        .then(function () {
            // load the transitive dependencies using the magic of
            // recursion.
            var dependencies = module.dependencies = module.dependencies || [];
            return Q.all(module.dependencies.map(function (depId) {
                depId = Identifier.resolve(depId, topId);
                // create dependees set, purely for debug purposes
                var module = getModuleDescriptor(depId);
                var dependees = module.dependees = module.dependees || {};
                dependees[topId] = true;
                return deepLoad(depId, topId, loading);
            }));
        }, function (error) {
            module.error = error;
        });
    }

    function lookup(topId, viaId) {
        topId = Identifier.resolve(topId, viaId);
        var module = getModuleDescriptor(topId);

        // check for consistent case convention
        if (module.id !== topId) {
            throw new Error(
                "Can't require module " + JSON.stringify(module.id) +
                " by alternate spelling " + JSON.stringify(topId)
            );
        }

        // handle redirects
        if (module.redirect !== void 0) {
            return lookup(module.redirect, topId);
        }

        // handle cross-package linkage
        if (module.mappingRedirect !== void 0) {
            return module.mappingRequire.lookup(module.mappingRedirect, "");
        }

        return module;
    }

    // Initializes a module by executing the factory function with a new
    // module "exports" object.
    function getExports(topId, viaId) {
        var module = getModuleDescriptor(topId);

        // check for consistent case convention
        if (module.id !== topId) {
            throw new Error(
                "Can't require module " + JSON.stringify(module.id) +
                " by alternate spelling " + JSON.stringify(topId)
            );
        }

        // check for load error
        if (module.error) {
            var error = module.error;
            error.message = (
                "Can't require module " + JSON.stringify(module.id) +
                " via " + JSON.stringify(viaId) +
                " in " + JSON.stringify(config.name || config.location) +
                " because " + error.message
            );
            throw error;
        }

        // handle redirects
        if (module.redirect !== void 0) {
            return getExports(module.redirect, viaId);
        }

        // handle cross-package linkage
        if (module.mappingRedirect !== void 0) {
            return module.mappingRequire(module.mappingRedirect, viaId);
        }

        // do not reinitialize modules
        if (module.exports !== void 0) {
            return module.exports;
        }

        // do not initialize modules that do not define a factory function
        if (module.factory === void 0) {
            throw new Error(
                "Can't require module " + JSON.stringify(topId) +
                " via " + JSON.stringify(viaId) + " " + JSON.stringify(module) +
                " because no factory was or exports were created by the module loader configuration"
            );
        }

        module.directory = URL.resolve(module.location, "./"); // EXTENSION
        module.exports = {};

        // Execute the factory function:
        var returnValue = module.factory.call(
            // in the context of the module:
            void 0, // this (defaults to global)
            module.require, // require
            module.exports, // exports
            module, // module
            module.location, // __filename
            module.directory // __dirname
        );

        // EXTENSION
        if (returnValue !== void 0) {
            module.exports = returnValue;
        }

        return module.exports;
    }

    // Finds the internal identifier for a module in a subpackage
    // The `seen` object is a memo of the packages we have seen to avoid
    // infinite recursion of cyclic package dependencies. It also causes
    // the function to return null instead of throwing an exception. I’m
    // guessing that throwing exceptions *and* being recursive would be
    // too much performance evil for one function.
    function identify(id2, require2, seen) {
        var location = config.location;
        if (require2.location === location) {
            return id2;
        }

        var internal = !!seen;
    
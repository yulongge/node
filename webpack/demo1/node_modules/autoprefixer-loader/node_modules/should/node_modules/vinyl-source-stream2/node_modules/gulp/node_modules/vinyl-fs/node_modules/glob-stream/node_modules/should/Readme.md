# should.js

[![Build Status](https://travis-ci.org/shouldjs/should.js.svg?branch=master)](https://travis-ci.org/shouldjs/should.js)

[![Selenium Test Status](https://saucelabs.com/browser-matrix/shouldjs.svg)](https://saucelabs.com/u/shouldjs)

_should_ is an expressive, readable, framework-agnostic assertion library. The main goals of this library are __to be expressive__ and __to be helpful__. It keeps your test code clean, and your error messages helpful.

_should_ extends the `Object.prototype` with a single non-enumerable getter that allows you to express how that object should behave. It also returns itself when required with `require`.

### Breaking changes for 4.x

Please check [wiki](https://github.com/shouldjs/should.js/wiki/Breaking-changes-4.x).

### .eql implementation in 4.x

In 4.x `.eql` implementation was changed to fix old bug in deepEqual from node's `assert` module. To do not allow to assume that `10` is equal to `'10'`. You can still use old .eql implementation via `should.config` flags.

## Example
```javascript
var should = require('should');

var user = {
    name: 'tj'
  , pets: ['tobi', 'loki', 'jane', 'bandit']
};

user.should.have.property('name', 'tj');
user.should.have.property('pets').with.lengthOf(4);

// If the object was created with Object.create(null)
// then it doesn't inherit `Object.prototype`, so it will not have `.should` getter
// so you can do:
should(user).have.property('name', 'tj');

// also you can test in that way for null's
should(null).not.be.ok;

someAsyncTask(foo, function(err, result){
  should.not.exist(err);
  should.exist(result);
  result.bar.should.equal(foo);
});
```
## To begin

 1. Install it:

    ```bash
    $ npm install should --save-dev
    ```

 2. Require it and use:

    ```js
    var should = require('should');

    (5).should.be.exactly(5).and.be.a.Number;
    ```

## In browser

Well, even when browsers by complains of authors has 100% es5 support, it does not mean it has not bugs. Please see [wiki](https://github.com/shouldjs/should.js/wiki/Known-Bugs) for known bugs.

If you want to use _should_ in browser, use the `should.js` file in the root of this repository, or build it yourself. To build a fresh version:

```bash
$ npm install
$ gulp script
```

The script is exported to `window.Should`. It is the same as using `should` statically:

```js
Should(5).be.exactly(5)
```

Also, in the case of node.js, `Object.prototype` is extended with `should` (hence the capital S in `window.Should`):

```js
window.should.be.exactly(window);
// the same
// window is host object
should.be.exactly(window);
// you should not really care about it

(5).should.be.exactly(5);
```
You can easy install it with npm or bower:
```
npm install should --save-dev
# or
bower install shouldjs/should.js
```

## API docs

Actual api docs generated by jsdoc comments and available at [http://shouldjs.github.io](http://shouldjs.github.io).

## Usage examples

Please look on usage in [examples](https://github.com/shouldjs/examples)

## .not

`.not` negates the current assertion.

## .any

`.any` allow for assertions with multiple parameters to assert any of the parameters (but not all). This is similar to the native JavaScript [array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).

# Assertions
## chaining assertions

Every assertion will return a `should.js`-wrapped Object, so assertions can be chained.
To help chained assertions read more clearly, you can use the following helpers anywhere in your chain: `.an`, `.of`, `.a`, `.and`, `.be`, `.have`, `.with`, `.is`, `.which`. Use them for better readability; they do nothing at all.
For example:
```js
user.should.be.an.instanceOf(Object).and.have.property('name', 'tj');
user.pets.should.be.instanceof(Array).and.have.lengthOf(4);
```
Almost all assertions return the same object - so you can easy chain them. But some (eg: `.length` and `.property`) move the assertion object to a property value, so be careful.

## .ok

Assert that a chained object is truthy in javascript (ie: not '', null, undefined, 0 , NaN).

Assert truthfulness:

```javascript
true.should.be.ok;
'yay'.should.be.ok;
(1).should.be.ok;
({}).should.be.ok;
```

or negated:

```javascript
false.should.not.be.ok;
''.should.not.be.ok;
(0).should.not.be.ok;
```

*Warning:* No assertions can be performed on null and undefined values.
e.g.
```js
  undefined.should.not.be.ok;
```
will give you `Uncaught TypeError: Cannot read property 'should' of undefined)`.

In order to test for null use
```js
(err === null).should.be.true;
```

## .true

Assert if a chained object === true:

```javascript
true.should.be.true;
'1'.should.not.be.true;
```

## .false

Assert if a chained object === false:

```javascript
false.should.be.false;
(0).should.not.be.false;
```

## .eql(otherValue)

Asserts if a chained object is *equal* to otherValue. The object is compared by its actual content, not just reference equality.

```javascript
({ foo: 'bar' }).should.eql({ foo: 'bar' });
[1,2,3].should.eql([1,2,3]);
// see next example it is correct, even if it is different types, but actual content the same
[1, 2, 3].should.eql({ '0': 1, '1': 2, '2': 3 });
```

By default for now `.eql` does not check object prototypes, so such test will pass:

```js
var b = {a: 2};
var a = Object.create(null);
a.a = 2;

b.should.be.eql(a);
```
If you do not want such behaviour you can do:

```js
should.config.checkProtoEql = true;
```
somewhere at the beginning of tests (or in tests where you need to test prototypes) and test upper will fail.

## .equal(otherValue) and .exactl
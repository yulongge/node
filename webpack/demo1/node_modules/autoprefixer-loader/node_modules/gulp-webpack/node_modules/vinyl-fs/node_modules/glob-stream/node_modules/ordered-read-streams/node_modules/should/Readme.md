# should.js

_should_ is an expressive, readable, test framework agnostic, assertion library. Main goals of this library __to be expressive__ and __to be helpful__. It means test code should be clean, and error messages enough helpfull to understand error.

It extends the `Object.prototype` with a single non-enumerable getter that allows you to express how that object should behave, also it returns itself when required with `require`.

## Example
```javascript
var should = require('should');

var user = {
    name: 'tj'
  , pets: ['tobi', 'loki', 'jane', 'bandit']
};

user.should.have.property('name', 'tj');
user.should.have.property('pets').with.lengthOf(4);

// if the object was created with Object.create(null)
// then it doesn't inherit `Object` and have the `should` getter
// so you can do:

should(user).have.property('name', 'tj');
should(true).ok;

someAsyncTask(foo, function(err, result){
  should.not.exist(err);
  should.exist(result);
  result.bar.should.equal(foo);
});
```
## To begin

 1. Install it:
    
    $ npm install should --save-dev
    
 2. Require it and use:

```javascript
var should = require('should');

(5).should.be.exactly(5).and.be.a.Number;
```

## In browser

If you want to use _should_ in browser, use version that is in root of repository (or build it yourself). It is builded with browserify (see [Makefile](https://github.com/visionmedia/should.js/blob/master/Makefile)). To build fresh version:

```bash
# you should have browserify
npm install -g browserify
make browser
```

This script exported to `window.Should`. It is the same as use `should` statically:

```js
Should(5).be.exactly(5)
```

Also as for node.js case `Object.prototype` extended with `should` (that is why `window.Should` used):

```js
window.should.be.exactly(window);
// the same
// window is host object 
should.be.exactly(window);
// you should not really care about it

(5).should.be.exactly(5);
```

*should.js* uses EcmaScript 5 very extensively so any browser that support ES5 is supported. (IE <=8 not supported).
See [kangax's compat table](http://kangax.github.io/es5-compat-table) to know which exactly.

You can easy install it with again npm or bower:
```
npm install should --save-dev
# or
bower install visionmedia/should.js
```

## Static should and assert module

For some rare cases should can be used statically, without `Object.prototype`.
It can be replacement for node assert module:

```javascript
assert.fail(actual, expected, message, operator) // just write wrong should assertion
assert(value, message), assert.ok(value, [message]) // should(value).ok
assert.equal(actual, expected, [message]) // should(actual).eql(expected, [message])
assert.notEqual(actual, expected, [message]) // should(actual).not.eql(expected, [message])
assert.deepEqual(actual, expected, [message]) // should(actual).eql(expected, [message])
assert.notDeepEqual(actual, expected, [message]) // should(actual).not.eql(expected, [message])
assert.strictEqual(actual, expected, [message]) // should(actual).equal(expected, [message])
assert.notStrictEqual(actual, expected, [message]) // should(actual).not.equal(expected, [message])
assert.throws(block, [error], [message]) // should(block).throw([error])
assert.doesNotThrow(block, [message]) // should(block).not.throw([error])
assert.ifError(value) // should(value).Error (to check if it is error) or should(value).not.ok (to check that it is falsy)
```
	
## .not

`.not` negate current assertion.

# Assertions
## chaining assertions

Every assertion will return a `should.js`-wrapped Object, so assertions can be chained.
You can use this helpers to just chain: `.an`, `.of`, `.a`, `.and`, `.be`, `.have`, `.with`, `.is`, `.which`. Use them for better readability, they do nothing at all.
For example:
```js
user.should.be.an.instanceOf(Object).and.have.property('name', 'tj');
user.pets.should.be.instanceof(Array).and.have.lengthOf(4);
```
Almost all assertions return the same object - so you can easy chain them. But some move assertion object to property value. See feather, it will be mention if object chainged.

## .ok

Assert if asseted object is truthy in javascript meaning of truthy ('', null, undefined, 0 , NaN, Infinity - is falsy, so all others are truthy).

Assert truthfulness:

```javascript
true.should.be.ok;
'yay'.should.be.ok;
(1).should.be.ok;
({}).should.be.ok;
```

or negated:

```javascript
false.should.not.be.ok;
''.should.not.be.ok;
(0).should.not.be.ok;
```

## .true

Assert if asseted object === true:

```javascript
true.should.be.true;
'1'.should.not.be.true;
```

## .false

Assert if asseted object === false:

```javascript
false.should.be.false;
(0).should.not.be.false;
```

## .eql(otherValue)

Assert if asserted object is *equal* to otherValue. This means that object compared by its actual content, not just reference equality.
 
```javascript
({ foo: 'bar' }).should.eql({ foo: 'bar' });
[1,2,3].should.eql([1,2,3]);
// see next example it is correct, even if it is different types, but actual content the same
[1, 2, 3].should.eql({ '0': 1, '1': 2, '2': 3 });
```
## .equal(otherValue) and .exactly(otherValue)

Assert if asserted object strictly equal to `otherValue` (using `===` - no type conversion for primitive types and reference equivalence for reference types).

```javascript
(4).should.equal(4);
'test'.should.equal('test');
[1,2,3].should.not.equal([1,2,3]);
(4).should.be.exactly(4);
```

## .startWith(str)

Assert that string starts with `str`.

```javascript
'foobar'.should.startWith('foo');
'foobar'.should.not.startWith('bar');
```
## .endWith(str)

Assert that string ends with `str`.